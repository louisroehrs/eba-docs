(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{211:function(e,t,a){"use strict";a.r(t);var n=a(0),s=Object(n.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[e._m(0),e._v(" "),a("p",[e._v("Welcome to EBA development! This article serves as a getting started guide for developers who are unfamiliar with our unique machine reasoning programming model. First, we provide a brief overview of EBA's collaborative reasoning pipeline. This will help you get a solid grasp of the fundamentals before you dive into building your first agent. Next, we provide a tutorial which guides the development of a sample Walmart agent from scratch. This agent will be able to answer various questions about trending products. You may reference and try out "),a("router-link",{attrs:{to:"./../samples/Walmart.html"}},[e._v("the complete working sample")]),e._v(" any time you wish.")],1),e._v(" "),e._m(1),e._v(" "),a("p",[e._v("The steps below essentially describe how EBA works, and demonstrates the journey of a user's question through EBA's collaborative reasoning pipeline.")]),e._v(" "),a("p",[e._v("Encoded conceptual knowledge: Developers encode a set of concepts and relationships to tell our assistant what it can understand and reason about. Without conceptual entities, there is effectively nothing to reason about.")]),e._v(" "),a("p",[e._v("SyntaxTree creation: A user’s natural language question is broken down into its morphological and syntactical features and represented as a tree.")]),e._v(" "),a("p",[e._v("Annotation: Natural language within a user’s syntax tree is annotated or mapped to conceptual entities.")]),e._v(" "),a("p",[e._v("Reasoning: Given a starting point of conceptual entities, EBA considers all possible outcome paths and reasons to produce the most relevant one.")]),e._v(" "),a("p",[e._v("Execution: Having settled on the appropriate action path, EBA executes that path including any side effects it may produce.")]),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),a("p",[e._v("We propose the following development workflow for building any agent. Note that you will likely follow this workflow in an iterative process for each new piece of knowledge that you want to introduce to the assistant.")]),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),e._m(10),e._v(" "),a("p",[e._v("Beginning with a completely empty configuration, we decide that our domain is mostly about one thing--products from Walmart. We want our assistant to understand products, so we begin by adding the following entries into our ontology tab.")]),e._v(" "),e._m(11),e._v(" "),e._m(12),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),a("p",[e._v("In order to enable full attribute support, we need to specify some additional information in the ontology. In short, we should tell the system these concepts are in fact attributes along with their corresponding spelling. We add the following entries.")]),e._v(" "),e._m(15),e._v(" "),e._m(16),e._v(" "),e._m(17),e._v(" "),e._m(18),e._v(" "),a("p",[e._v("It is now a good time to add patterns, actions, and visualization to support questions related to products.")]),e._v(" "),e._m(19),e._v(" "),a("p",[e._v("We want Watson to map natural language from user questions to the concept language we have just defined in our ontology. Patterns enable this mapping via token annotations. We add the following patterns:")]),e._v(" "),e._m(20),e._v(" "),e._m(21),e._v(" "),a("p",[e._v("The result of entering these patterns is that whenever the user asks something like 'show me the msrp for this product'. An annotation tree can be created with the appropriate concepts in place. This annotation tree then becomes the starting point for reasoning.")]),e._v(" "),e._m(22),e._v(" "),e._m(23),e._v(" "),e._m(24),e._v(" "),e._m(25),e._v(" "),e._m(26),e._v(" "),a("p",[e._v("As a quick test of Watson's natural language understanding, we can declare our actions and return hard coded responses just to verify that our questions are correctly understood. Once understanding is in place, we can hook up actual API calls to Walmart and return real data.")]),e._v(" "),e._m(27),e._v(" "),e._m(28),e._v(" "),e._m(29),e._v(" "),a("p",[e._v("We can add the following hardcoded placeholder action to test Watson's understanding of a question:")]),e._v(" "),e._m(30),a("p",[e._v("In this placeholder code, we import our standard "),a("router-link",{attrs:{to:"./../lab/NodeHelpers.html"}},[e._v("eba helpers package")]),e._v(". This package is useful for working with parameters, results, and other features of our system. In the code above, we are returning a Result which sets data for the "),a("code",[e._v("wmt:Products")]),e._v(" concept as a hard coded list of strings, viz. 'product1', 'product2', and 'product3'.")],1),e._v(" "),a("p",[e._v("Save your changes and try the following questions in the chat: 'show me trending products' or 'what products are trending?'. Watson should respond with the hard coded list above. You can verify Watson's understanding by clicking the information icon above your original question. This should show you the annotation tree of your question. You can view the complete context of your chat in the information space as well by clicking the graph icon in the top right corner of the page.")]),e._v(" "),e._m(31),e._v(" "),a("p",[e._v("Now replace the code in your placeholder action with the following:")]),e._v(" "),e._m(32),e._m(33),e._v(" "),a("p",[e._v("Save your changes and try out the same questions again. You should see real data returned in this case.")]),e._v(" "),a("p",[e._v("Let's add the remaining actions we want to support for this sample.")]),e._v(" "),e._m(34),e._v(" "),e._m(35),e._v(" "),a("p",[e._v("Add the following code into the action body:")]),e._v(" "),e._m(36),e._m(37),e._v(" "),e._m(38),a("p",[e._v("The last action to be programmed is similar to one above, except that it is UPC based search. Instead of searching against a name string, we will be searching against a number.")]),e._v(" "),e._m(39),e._v(" "),e._m(40),e._v(" "),a("p",[e._v("With these actions in place, we have decent coverage for questions which search for trending products as well as questions which perform general product search by name or upc. On top of these questions, Watson provides you with out of the box support for filtering, sorting, aggregation, etc.")]),e._v(" "),a("p",[e._v("Here is a short list of questions you should be able to ask at this point within the tutorial.")]),e._v(" "),e._m(41),e._v(" "),e._m(42),e._v(" "),a("p",[e._v("Watson is able to understand our questions, but these raw JSON responses are not very pretty. We should add some visualizers to our front end.")]),e._v(" "),e._m(43),e._v(" "),e._m(44),e._v(" "),a("p",[e._v("Add the following jsx code to your asset:")]),e._v(" "),e._m(45),e._m(46),e._v(" "),a("p",[e._v("In the css file, add the following styles:")]),e._v(" "),e._m(47),a("p",[e._v("We now have some nice visualizations for our responses. Save your changes and try them out. Note: if you do not see any changes, try refreshing your browser. Session refresh and browser refresh are two distinct operations within our application.")]),e._v(" "),e._m(48),e._v(" "),e._m(49)])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"getting-started-tutorial"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#getting-started-tutorial","aria-hidden":"true"}},[this._v("#")]),this._v(" Getting started tutorial")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"reasoning-pipeline"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reasoning-pipeline","aria-hidden":"true"}},[this._v("#")]),this._v(" Reasoning pipeline")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"development-workflow"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#development-workflow","aria-hidden":"true"}},[this._v("#")]),this._v(" Development workflow")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[a("a",{attrs:{href:"#ontology"}},[e._v("ontology")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#patterns"}},[e._v("patterns")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#actions"}},[e._v("actions")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#rules"}},[e._v("rules")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#visualizers"}},[e._v("visualizers")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("First, there should be an understanding of the domain you wish to model. You should ask yourself basic questions such as: What sorts of questions do I want the assistant to answer? What domain entities are used in such questions? Which attributes of these entities should I expose? How do these entities relate to one another? With this understanding in mind, you can begin to program an "),t("a",{attrs:{href:"#ontology"}},[this._v("ontology of concepts")]),this._v(". Watson understands the world in terms of concepts. A concept is simply a domain object which your agent can recognize and understand given a sort of base definition. Likewise, an ontology is simply a set of relationships between concepts.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Secondly, we encourage the developer to implement "),t("a",{attrs:{href:"#patterns"}},[this._v("natural language patterns")]),this._v(". These patterns serve as a bridge between natural language and the conceptual language which Watson is able to understand. In these patterns, you will match natural language tokens to their corresponding concepts. Natural language patterns are more than a mere keyword match; rather, they capture the syntactical context in which a token is used. For instance, consider the following the pattern:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("code",[this._v("what is the {weather|:Weather} today?")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("The term 'weather' signifies a noun subject in this case. However, the word 'weather' can contain a very different semantic meaning in other sentences, e.g. 'can we weather the storm?'. Based on the natural language pattern above, Watson will understand that this usage of 'weather' is different from the first usage and, subsequently, it will not introduce the concept "),t("code",[this._v(":Weather")]),this._v(" into its reasoning pipeline when answering the second type of question.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Next we propose that "),t("a",{attrs:{href:"#actions"}},[this._v("semantic actions")]),this._v(" and "),t("a",{attrs:{href:"#rules"}},[this._v("rewriting rules")]),this._v(" should be developed. Reasoning in EBA is performed on a graph, where concepts represent nodes within this graph. The goal of actions is to produce real data for these concepts. For instance, if a user asks 'show me all products'. Watson will reason about the concept "),t("code",[this._v("wmt:Products")]),this._v(" during reasoning time. During execution time, when it is ready to produce a response to this question, it should be able to produce real data via an executor function. This function may make a call to an external api or database to produce data. A rule, on the other hand, represents a kind of translation between concepts. Typically we will translate higher level concepts into lower level concepts.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Lastly, we encourage the development of visualizations for the data you are producing from your actions. All the data produced in your actions will be passed to your front end visualizers so that you can customize the visualization of your data. Visualizers are implemented as front end "),t("a",{attrs:{href:"#visualizers"}},[this._v("assets")]),this._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"ontology"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ontology","aria-hidden":"true"}},[this._v("#")]),this._v(" Ontology")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("table",[a("thead",[a("tr",[a("th",[e._v("Name")]),e._v(" "),a("th",[e._v("Spelling")]),e._v(" "),a("th",[e._v("SubClass of")]),e._v(" "),a("th",[e._v("List of")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("wmt:Product")])]),e._v(" "),a("td",[a("code",[e._v("product")])]),e._v(" "),a("td",[a("code",[e._v(":Showable")])]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("wmt:Products")])]),e._v(" "),a("td",[a("code",[e._v("products|*")])]),e._v(" "),a("td",[a("code",[e._v(":Showable")])]),e._v(" "),a("td",[a("code",[e._v("wmt:Product")])])])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("We have just provided the following information to our system. We can recognize two concepts, viz. "),a("code",[e._v("wmt:Product")]),e._v(" and "),a("code",[e._v("wmt:Products")]),e._v(". Each of these concepts have an appropriate spelling which will be used in natural language generation (NLG). NLG enables Watson to compose appropriate responses to the user in the same terms as the original questions. For example, when asking for product 123, Watson may reply 'I have found the following "),a("strong",[e._v("product")]),e._v(" with id 123'. This helps to eliminate hard coded responses. Furthermore, each of these concepts is a subclass of "),a("code",[e._v(":Showable")]),e._v(" meaning that the data associated with these concepts can actually be shown to user within the chat panel. Lastly, we have specified that products is a list of individual product elements, which helps to enable useful operations on the collection such as filtering, sorting, etc.")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("We want "),a("code",[e._v("wmt:Product")]),e._v(" to correspond to our real data model coming from the Walmart Api. Now Walmart's open api will return something on the order of "),a("code",[e._v("{ name: 'some name', msrp: 'some msrp', shortDescription: 'some description', 'salePrice': 'some price' ... }")]),e._v(", so we will want to map these json field names to actual concepts within our systems. They will serve as attributes for "),a("code",[e._v("wmt:Product")]),e._v(". This enables EBA to understand "),a("code",[e._v("wmt:Product")]),e._v(" in terms of its component attributes.")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("table",[a("thead",[a("tr",[a("th",[e._v("Attribute")]),e._v(" "),a("th",[e._v("JSON Field")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v(":Name")])]),e._v(" "),a("td",[a("code",[e._v("name")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("wmt:MSRP")])]),e._v(" "),a("td",[a("code",[e._v("msrp")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("wmt:SalePrice")])]),e._v(" "),a("td",[a("code",[e._v("salePrice")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("wmt:Description")])]),e._v(" "),a("td",[a("code",[e._v("shortDescription")])])])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("table",[a("thead",[a("tr",[a("th",[e._v("Name")]),e._v(" "),a("th",[e._v("Spelling")]),e._v(" "),a("th",[e._v("Subclass of")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("wmt:MSRP")])]),e._v(" "),a("td",[a("code",[e._v("msrp")])]),e._v(" "),a("td",[a("code",[e._v(":Attribute")]),e._v(", "),a("code",[e._v(":NumAttribute")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("wmt:SalePrice")])]),e._v(" "),a("td",[a("code",[e._v("sale price")])]),e._v(" "),a("td",[a("code",[e._v(":Attribute")]),e._v(", "),a("code",[e._v(":NumAttribute")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("wmt:Description")])]),e._v(" "),a("td",[a("code",[e._v("description")])]),e._v(" "),a("td",[a("code",[e._v(":Attribute")]),e._v(", "),a("code",[e._v(":NumAttribute")])])])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("By making a concept subclass from "),a("code",[e._v(":Attribute")]),e._v(" we tell the system that it is an attribute. This system will then generate certain actions in the back end to enable attribute queries such as "),a("code",[e._v("show me the msrp of this product")]),e._v(". We additionally specify that type of the attribute, i.e. whether it is a string, number, or date attribute, which helps enable filtering questions such 'show me products with msrp below 100'.\nLastly, they each contain an appropriate spelling for NLG. Note that we did not enter any data for "),a("code",[e._v(":Name")]),e._v(". This concept is already natively supported by our system, hence the lack of domain prefix. Note that attributes are treated as "),a("code",[e._v(":Showable")]),e._v(" for our system, so it is redundant to add this subclass entry.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("As mentioned in the introduction, we will want to iteratively test each new piece of knowledge that we add to our system. Since this sample is small enough we can add two more auxiliary nodes to cover all relevant types of questions. Lets add entries for "),t("code",[this._v(":UPC")]),this._v(", "),t("code",[this._v("wmt:Trending")]),this._v(", "),t("code",[this._v("wmt:TrendingNow")]),this._v(".")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("table",[a("thead",[a("tr",[a("th",[e._v("Name")]),e._v(" "),a("th",[e._v("Spelling")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v(":UPC")])]),e._v(" "),a("td",[a("code",[e._v("UPC")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("wmt:Trending")])]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("wmt:TrendingNow")])]),e._v(" "),a("td")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"patterns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#patterns","aria-hidden":"true"}},[this._v("#")]),this._v(" Patterns")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[a("code",[e._v("show me all {trending|wmt:Trending} {products|wmt:Products}")])]),e._v(" "),a("li",[a("code",[e._v("show {popular|wmt:Trending} products")])]),e._v(" "),a("li",[a("code",[e._v("what is the {description|wmt:Description}, {price|wmt:SalePrice}, and {msrp|wmt:MSRP} for this {product|wmt:Product}?")])]),e._v(" "),a("li",[a("code",[e._v("{what's|:What} {trending now|wmt:TrendingNow}")])]),e._v(" "),a("li",[a("code",[e._v("show me the product name for {upc|:UPC} 123")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("The first pattern tells the system that the token 'products', when used in a similar syntactic context, should be annotated with the "),t("code",[this._v("wmt:Products")]),this._v(" concept. The third pattern does the same for our attribute concepts as well as the product concept. Note that in this tutorial we have added four annotations on a single line in the second entry. It is possible to list each of these annotations as a separate entry, and, in fact, our posted walmart sample does this; however, the more compact representation above can be another good option. The last two entries supply annotations for our auxiliary concepts.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"rules"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rules","aria-hidden":"true"}},[this._v("#")]),this._v(" Rules")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("So far, any time that we want to search for products we must have the keyword 'products' within the original sentence. It is likely that real users will want to ask less qualified questions, such as "),t("code",[this._v("whats trending now?")]),this._v(". It is clear to us that this is a request to search for current trending products. Watson will likewise understand this if we add the following rewriting rule:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("code",[this._v("wmt:TrendingNow -> wmt:Trending(wmt:Products)")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("A rewriting rule effectively rewrites a higher level concept into a set of already existing lower level concepts. Here we are rewriting a request for "),t("code",[this._v("wmt:TrendingNow")]),this._v(" into a request for trending products. We already added a pattern for this concept, so save your changes and try the question 'what's trending now'?")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"actions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#actions","aria-hidden":"true"}},[this._v("#")]),this._v(" Actions")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Let's support the most basic action first. We want to get all trending products for Walmart. In order to do so we must declare the appropriate action signature. Action signatures are broken into three components, viz. constraints, input, and output, where constraints are optional and can be omitted. Signatures conform the following formula: "),t("code",[this._v("constraints => input -> output")]),this._v(". In short, anything on the left of the "),t("code",[this._v("=>")]),this._v(" is a constraint and should be entered in the constraint column. The next part should be entered in the input column, and the last part in the output column.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("table",[t("thead",[t("tr",[t("th",[this._v("Name")]),this._v(" "),t("th",[this._v("Signature")])])]),this._v(" "),t("tbody",[t("tr",[t("td",[t("code",[this._v("wmt:GetTrendingProducts")])]),this._v(" "),t("td",[t("code",[this._v("wmt:Products(wmt:Trending) -> data wmt:Products")])])])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("Lets reflect on the signature above. We expect questions such as 'show me all trending products' and 'what products are trending?'. We note that "),a("code",[e._v("wmt:Products")]),e._v(" is the root object in such queries and that the keyword 'trending' is a modifier which qualifies this concept. Hence we define our input in the following manner  "),a("code",[e._v("wmt:Products(wmt:Trending)")]),e._v(". "),a("code",[e._v("wmt:Products")]),e._v(" is the root concept and it points to a child concept "),a("code",[e._v("wmt:Trending")]),e._v(" which modifies it. Lastly, in this action we plan to produce data for products, so we add "),a("code",[e._v("data wmt:Products")]),e._v(" as the output.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("const {Result} = require('eba');\nmodule.exports.main = () => new Result().setData('wmt:Products', ['product1', 'product2', 'product3']);\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Now that we have verified that Watson can understand such questions, we should produce real data from Walmart. In order to use walmart's open api, you should register for a free api key online at https://developer.walmartlabs.com/. Once you have obtained an api key, switch over to the General tab within our dev lab. In the secrets panel, add the following name:value pair: "),t("code",[this._v("apiKey")]),this._v(" : "),t("code",[this._v("<value of your own api key from link above>")]),this._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("const request = require('request-promise-native')\nconst eba = require('eba');\n\nconst main = ({secrets}) => {\n  return request\n    .get(`http://api.walmartlabs.com/v1/trends?apiKey=${secrets.apiKey}`)\n    .then(JSON.parse)\n    .then(({items}) => {\n      items.forEach((item) => {\n        if (!item.shortDescription)\n          item.shortDescription = \"\"\n      })\n      return new eba.Result().setData('wmt:Products', items);\n    })\n    .catch((error) => {\n      return { error: `Walmart API error: ${error}` }\n    })\n}\nmodule.exports = {main}\n")])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("The action above is relatively straightforward. We are performing an http GET request to Walmart's /trends api. In this request, we are passing our apiKey which we just stored in our secrets (accessed via "),a("code",[e._v("secrets.apiKey")]),e._v("). We then parse the JSON result and perform some data minor data processing to ensure that each item returned from the api has a "),a("code",[e._v("shortDescription")]),e._v(" field, even if it is empty. The api can otherwise return some items where this field is missing. Recall from our ontology entries that "),a("code",[e._v("wmt:Products")]),e._v(" is a list of "),a("code",[e._v("wmt:Product")]),e._v(" and that "),a("code",[e._v("wmt:Product")]),e._v(" is composed a few fields, one of which is the short description. Lastly, we return a Result which sets data as this processed list of items from walmart.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("table",[t("thead",[t("tr",[t("th",[this._v("Name")]),this._v(" "),t("th",[this._v("Signature")])])]),this._v(" "),t("tbody",[t("tr",[t("td",[t("code",[this._v("wmt:SearchProductByName")])]),this._v(" "),t("td",[t("code",[this._v("wmt:Product(optional :WithName(data :UserString)) -> data wmt:Product")])])])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("Here we are defining an action for searching for a particular product by name. "),a("code",[e._v("wmt:Product")]),e._v(" is the root concept and it can be optionally qualified by a "),a("code",[e._v(":WithName")]),e._v(" keyword followed by actual string data containing the product name to be searched against. By "),a("code",[e._v(":WithName")]),e._v(" keyword we mean a keyword which signifies a name, e.g. 'show me products "),a("strong",[e._v("named")]),e._v(" \"Call of Duty\"' or 'show me products "),a("strong",[e._v("with name")]),e._v(' "Call of Duty"\'. Since we are not using any named entity recognition in this sample, we are supplying the product name within quoted strings. Such quoted strings are denoted by '),a("code",[e._v(":UserString")]),e._v(" concept. Note that "),a("code",[e._v(":UserString")]),e._v(" is a convenience concept for local development and is not meant for production quality assistants. Named entity recognition for keywords is strongly encouraged in such cases. The output of this action should be data for a single product.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("const request = require('request-promise-native')\nconst eba = require('eba')\n\nmodule.exports.main = function (params) {\n  let h = new eba.Params(params)\n  let nameString = h.get(\":UserString\")\n\n  return request\n    .get(`http://api.walmartlabs.com/v1/search?apiKey=${params.secrets.apiKey}&query=${encodeURIComponent(nameString)}`)\n    .then(JSON.parse)\n    .then(({items}) => {\n      let item = items[0]\n      if (item) {\n        if (!item.shortDescription)\n          item.shortDescription = \"\"\n        return new eba.Result().setData('wmt:Product', item)\n      } else {\n        return { error: \"I haven't found any product\" }\n      }\n    })\n    .catch((error) => {\n      return { error: `Walmart API error: ${error}` }\n    })\n}\n")])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("This action is similar to what we have created already. Note that we are using "),a("code",[e._v("eba")]),e._v(" helpers pacakge to access the value of the "),a("code",[e._v(":UserString")]),e._v(" via "),a("code",[e._v('let nameString = h.get(":UserString")')]),e._v(". We then supply the name and api key to the query string. When returning the results, we only take the first element returned and performing the same data processing as before. We are taking the first element as this action is meant to returning an object not a collection. Since it is possible to return multiple items with the same name from this api, we should add an action similar to the one above which can return this collection. We leave this as an exercise to the reader, as it is exactly the same signature but "),a("code",[e._v("wmt:Products")]),e._v(" is used instead of "),a("code",[e._v("wmt:Product")]),e._v(" and the data processing step is the same, except that is performed for each element in the collection instead of the first element:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("items.forEach((item) => {\n    if (!item.shortDescription)\n        item.shortDescription = \"\"\n})\nreturn new eba.Result().setData('wmt:Products', items);\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("table",[t("thead",[t("tr",[t("th",[this._v("Name")]),this._v(" "),t("th",[this._v("Signature")])])]),this._v(" "),t("tbody",[t("tr",[t("td",[t("code",[this._v("wmt:SearchProductByUPC")])]),this._v(" "),t("td",[t("code",[this._v("wmt:Product(optional :UPC(data :Number)) -> data wmt:Product")])])])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("Rather than a "),a("code",[e._v(":WithName")]),e._v(" keyword, we expect a "),a("code",[e._v(":UPC")]),e._v(" keyword as well as a "),a("code",[e._v(":Number")]),e._v(". Hence questions such as "),a("code",[e._v("show me product with UPC 123")]),e._v(" will be supported by this action. The body of this action is likewise similar to its search-by-name counterpart. The only differences is that we unwrap "),a("code",[e._v("h.get(':Number')")]),e._v(" and we supply a different query string, viz. "),a("code",[e._v("http://api.walmartlabs.com/v1/items?apiKey=${params.secrets.apiKey}&upc=${encodeURIComponent(upc)")]),e._v(".")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[e._v("which products are trending?")]),e._v(" "),a("li",[e._v("show me top 5 popular products")]),e._v(" "),a("li",[e._v("show me average price of these")]),e._v(" "),a("li",[e._v("what is product name for UPC 647627503349?")]),e._v(" "),a("li",[e._v('show me products named "call of duty"')]),e._v(" "),a("li",[e._v("show me popular products with positive description")]),e._v(" "),a("li",[e._v("show me popular products with price less than $50")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"visualizers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#visualizers","aria-hidden":"true"}},[this._v("#")]),this._v(" Visualizers")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("Switch to the Assets tab, create two assets, and mark them as front end. The first asset is "),a("code",[e._v("wmt/products.jsx")]),e._v(" and the second is "),a("code",[e._v("wmt/product.css")]),e._v(". Make sure you set the type of each file appropriately, viz. "),a("code",[e._v("text/jsx")]),e._v(" and "),a("code",[e._v("text/css")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("In the jsx file we will declare the following objects, viz. "),t("code",[this._v("wmt_ProductsData")]),this._v(" and "),t("code",[this._v("wmt_ProductData")]),this._v(". Each concept can be assigned a visualization following the pattern: "),t("code",[this._v("<namespace>_<Concept>Data")]),this._v(". The data produced by our actions is passed to these functions for visualization.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('wmt_ProductsData = ({data}) => {\n  return (\n    <div className="wmt-products">\n      { data.map((item) =>\n        React.createElement(\n          wmt_ProductData,\n          {data:item, key:item.itemId})) }\n    </div>)\n}\n\nwmt_ProductData = ({data}) => {\n  const item = data\n  return (\n    <div key={item.itemId} className="wmt-product">\n      <div className="wmt-product-info">\n        <a href={item.addToCartUrl} target="_blank" className="wmt-product-info-image">\n          <img src={item.mediumImage}/>\n        </a>\n        <div className="wmt-product-info-name">\n          <p><strong>{item.name}</strong></p>\n          <p>\n            {new Number(item.salePrice)\n              .toLocaleString("en-US", {\n                  style: "currency",\n                  currency: "USD"})\n              .replace(/\\.00/,"")}\n            {item.msrp && item.salePrice/item.msrp < 0.99 ?\n              <span> {"\\u2014 "}\n                <span className="wmt-product-discount">\n                  {new Number(1-item.salePrice/item.msrp)\n                    .toLocaleString("en-US", {style: "percent"})}\n                  {" off MSRP"}\n                </span>\n              </span> : null}\n          </p>\n        </div>\n      </div>\n      <div className="wmt-product-info-description">\n        <div dangerouslySetInnerHTML={{__html:wmt_decodeHTMLEntities(item.shortDescription\n)}}/>\n      </div>\n    </div>)\n}\n\nwmt_decodeHTMLEntities = (encoded) => {\n  if (encoded) {\n    var elem = document.createElement(\'textarea\')\n    elem.innerHTML = encoded.replace(/[\\uFFFD]/g,\' \')\n    return elem.value\n  }\n  else return ""\n}\n\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Our system understands that products is a list of product elements, so in our products visualizer, we simply call "),t("code",[this._v("data.map")]),this._v(" to render each individual product. Inside of the product visualizer, we implement an html outline and fill in the tags with raw data from our product, e.g. "),t("code",[this._v("item.mediumImage")]),this._v(". These html tags make use of a few styles which we will expose in our second asset.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(".wmt-product {\n  margin-bottom: 20px;\n}\n.wmt-product:last-child {\n  margin-bottom: 0;\n}\n.wmt-product-info {\n  display: flex;\n  align-items: center;\n  margin-bottom: 10px;\n}\n.wmt-product-info img {\n  max-width: 100px;\n  margin-right: 15px;\n}\n.wmt-product-discount {\n  color: red;\n}\n.wmt-product-info-description {\n  display: block;\n  overflow: hidden;\n  line-height: 16px;\n  max-height: calc(16px * 5);\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 5;\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"next-steps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#next-steps","aria-hidden":"true"}},[this._v("#")]),this._v(" Next Steps")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("At this point, you should have a working Walmart sample, which is almost identical to the sample we have posted online. There are always a points of improvement. We leave these as an exercise to the reader. For instance, you may have noticed that our action bodies are almost identical. In this case, we may create a back end asset which encapsulates our http request to walmart by exposing a simple "),t("code",[this._v("get")]),this._v(" function with takes certain configuration parameters. You can then import this asset within your actions and perform a single function call to return the appropriate data. Additionally, the NLG could be improved for a few responses. You may reference our other public samples for examples on how to tune NLG using our helpers package. And, of course, feel free to extend the sample according to your desire.")])}],!1,null,null,null);t.default=s.exports}}]);