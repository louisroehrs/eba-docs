(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{260:function(e,t,a){"use strict";a.r(t);var o=a(0),s=Object(o.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[e._m(0),e._v(" "),a("p",[e._v("As described in our "),a("router-link",{attrs:{to:"./Actions.html"}},[e._v("action component")]),e._v(", EBA supports a parameter type called "),a("code",[e._v("promise")]),e._v(", which enables data to be produced for an action only once some prelimenrary data is first acquired. This is typically accomplished by the use of follow up questions in a dialog series. For a live example of this feature, you may try out our "),a("a",{attrs:{href:"https://eba.ibm.com/assistant#/lab/agents/weather/actions",target:"_blank",rel:"noopener noreferrer"}},[e._v("Weather agent"),a("OutboundLink")],1),e._v(". In this article, we will walk you through the steps of implementing a few promise dialogs, using our Weather agent as a reference.")],1),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),a("p",[e._v("Or, let's say that you are resolving a user's question and the runtime execution indicates an ambiguous case which needs to be resolved by a follow up? For example, if the user asks for a certain entity but you need to establish which type or which class it should be belong to. In these cases, a follow up dialog can be used to resolve any disambiguation.")]),e._v(" "),a("p",[e._v("Of course, in all these cases a user can ask a fully qualified question, in which case no follow up dialog is required, e.g. 'show me the weather in San Fransisco two days from now'. However, we do not anticipate or assume that this will always be the case, and, as a result, we enable developers to handle less qualified requests for data.")]),e._v(" "),e._m(3),e._v(" "),e._m(4),a("p",[e._v("From this code, we note two things. First, we rename our concept to "),a("code",[e._v(":Question")]),e._v(" using the "),a("code",[e._v("setName")]),e._v(" api detailed in our "),a("router-link",{attrs:{to:"./../lab/NodeHelpers.html"}},[e._v("node helpers")]),e._v(". Secondly, as data, we supply the follow up question itself. With these two elements in place, our system will be able to understand that "),a("code",[e._v("weather:Weather")]),e._v(" cannot be resolved in the current execution; instead, it should display a follow up question.")],1),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),e._m(9)])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"promises"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promises","aria-hidden":"true"}},[this._v("#")]),this._v(" Promises")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"asking-for-follow-up-information"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#asking-for-follow-up-information","aria-hidden":"true"}},[this._v("#")]),this._v(" Asking for follow-up information")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Let's say that you have a business entity which requires, as a necessary condition in order to fetch the entity, another data element(s). In our case, this is "),t("code",[this._v("weather:Weather")]),this._v(" which requires both a city as well as a timeframe.")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("To handle less qualified requests, the following strategy can be employed. When a reference to your entity occurs, you can implement an action which returns a "),a("code",[e._v("promise")]),e._v(" node as output, rather than a "),a("code",[e._v("data")]),e._v(" node. For instance, "),a("code",[e._v("weather:Weather -> promise weather:Weather")]),e._v(" signifies an unqualified case (the users asks something general as 'what is the weather?'). We cannot produce "),a("em",[e._v("data")]),e._v(" for "),a("code",[e._v("weather:Weather")]),e._v(" until we first obtain a location. The code for such an action can look something like the following:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("const {Result} = require('eba')\n\nmodule.exports.main = (params) => {\n  return new Result()\n    .setName('weather:Weather', ':Question')\n    .setData('weather:Weather', 'Which location should I get the weather for?')\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Note that more complex cases can be modeled, e.g. our "),t("code",[this._v("weather:Forecast")]),this._v(" requires both a timeframe as well as a location in order for data to be produced. We can either model this a 3-step sequence, viz. ask for forecast, ask for location, and, finally, ask for timeframe. Or we can model it as 2-step sequence, viz. ask for forecast and timeframe or location and then ask for the remaining element. Or we can be flexible enough to support both variants. This will depend largely on the agent's business requirements. In our implementation of "),t("code",[this._v("weather:Forecast")]),this._v(", we have followed the second route. Accordingly, you will find the following signatures in our implementation:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[t("code",[this._v("weather:Forecast(optional :Relation(data :Timeframe) -> promise weather:Forecast")])]),this._v(" "),t("li",[t("code",[this._v("weather:Forecast(optional :Relation(city)) -> promise weather:Forecast")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("You will find that the body of such actions all follow the similar pattern described above, viz. rename to "),t("code",[this._v(":Question")]),this._v(" with supplied NL question.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"generating-data"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generating-data","aria-hidden":"true"}},[this._v("#")]),this._v(" Generating data")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("With a "),a("code",[e._v("promise")]),e._v(" node in place, our system will attempt to resolve it, i.e. to convert it to a "),a("code",[e._v("data")]),e._v(" node, whenever it is suitable. To enable such behavior, we should implement an additional action to produce real data. Of course, this action will contain as input all concepts required to resolve the entity at hand. In the case of weather, we have an action as "),a("code",[e._v("weather:Forecast")]),e._v(", we have an action "),a("code",[e._v("weather:Forecast (optional :Relation (data city), optional :Relation (data :Timeframe)) -> data weather:Forecast")]),e._v(". Note that this action requires both city and timeframe data and the output produces "),a("code",[e._v("data weather:Forecast")]),e._v(", meaning that it can provide the data which the user initially requested. The body of this action will use the supplied input to perform any api calls necessary. All actions for the weather agent as viewable to our users. Feel free to take a look and explore this feature in your own implementations.")])}],!1,null,null,null);t.default=s.exports}}]);