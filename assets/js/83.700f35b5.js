(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{261:function(e,t,a){"use strict";a.r(t);var i=a(0),s=Object(i.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[e._m(0),e._v(" "),a("p",[e._v("This document covers each of the core components that constitute a skill. It is important to note that EBA follows an ontology based paradigm, meaning that it derives understanding about the world based on a relationship of concepts. This is in contrast to most other systems which are intent based and depend on predicate logic.")]),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),a("p",[e._v("We begin our understanding of ontology by first looking at the notion of a concept.")]),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),a("p",[e._v("Here we specify that :OpenRate is a concept which subclasses or derives from the :Showable concept. This system is able to visually render all :Showable objects, so we are effectively making our open rate concept viewable to the end user.")]),e._v(" "),e._m(8),a("p",[e._v("Here we specify that the :Mailings concept is a list composed of individual :Mailing concepts. This is useful for actions that the assistant performs when working with collections.")]),e._v(" "),a("p",[e._v("Certain native predicates have significant meaning for our system. We will detail a few of them below.")]),e._v(" "),e._m(9),e._v(" "),e._m(10),e._v(" "),a("p",[e._v("In EBA attributes are modeled via concepts, ontology, and semantic actions. Most of these components are auto-generated by EBA when an agent is loaded. For a developer there are only a few relations needed to be defined in the ontology:")]),e._v(" "),e._m(11),e._v(" "),a("p",[e._v('All of this ontology definitions can be done at "Concepts" tab in EBA Dev Lab.')]),e._v(" "),a("p",[e._v("EBA handles attributes on the assumption that entities are represented by JSON objects and collections are represented by JSON array of JSON objects. EBA only supports primitive types as attribute values. To enable type-specific OOB semantic actions (like ranking for numerical attributes, fuzzy search for string attributes) you need to define additional ontology:")]),e._v(" "),e._m(12),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),e._m(15),e._v(" "),e._m(16),e._v(" "),e._m(17),e._v(" "),e._m(18),e._v(" "),a("p",[e._v("EBA is an ecosystem of domain specific agents. In order to encapsulate and expose common functionality across our system, EBA contains a set of prebuiilt native agents. These agents, like any other agents, implement a set of concepts which can be utilized and extended by other agents within the ecosystem. In this article, we aim to highlight the key set of concepts which developers may want to familarize themselves with in order to better understand the generic functionalities they have available. The catalog below is not meant to be exhaustive, and, as with all our agents, you can view their further details within our dev lab at eba.ibm.com.")]),e._v(" "),e._m(19),e._v(" "),e._m(20),e._v(" "),a("p",[e._v("Concepts which represent a high level interface for capturing the role of your concept, e.g. a textual message or a showable data element.")]),e._v(" "),e._m(21),e._v(" "),e._m(22),e._v(" "),e._m(23),e._v(" "),e._m(24),e._v(" "),e._m(25),e._v(" "),a("p",[e._v("These concepts represent the basic types of data which our system provides OOB.")]),e._v(" "),e._m(26),e._v(" "),e._m(27),e._v(" "),e._m(28),e._v(" "),e._m(29),e._v(" "),e._m(30),e._v(" "),e._m(31),e._v(" "),e._m(32),e._v(" "),e._m(33),e._v(" "),e._m(34),e._v(" "),e._m(35),e._v(" "),a("p",[e._v("These concepts pertain to extending custom NLG capabilties.")]),e._v(" "),e._m(36),e._v(" "),e._m(37),e._v(" "),a("p",[e._v("Patterns are simply natural language text samples annotated with concepts. When the assistant receives a question from the user, it is able to tokenize and parse this input into a tree. By using natural language patterns, it is able to annotate this tree with the appropriate concepts. For example consider the patterns below.")]),e._v(" "),e._m(38),e._m(39),e._v(" "),e._m(40),e._v(" "),e._m(41),e._v(" "),e._m(42),e._v(" "),e._m(43),e._v(" "),e._m(44),e._v(" "),e._m(45),a("p",[e._v('Here we have defined the best mailing to be translated into lower level concepts. :HighValue is a concept used by the system to return highest quartile data points and :ClickToOpenRate is an attribute of :Mailing. We are effectively programming our assistant to recognize "the best mailings" as being equivalent to "mailings with clickToOpenRate attribute in the highest quartile".')]),e._v(" "),e._m(46),e._v(" "),e._m(47),e._v(" "),e._m(48),e._v(" "),e._m(49),e._v(" "),e._m(50),e._v(" "),e._m(51),e._v(" "),e._m(52),e._v(" "),e._m(53),e._m(54),e._v(" "),a("p",[e._v("Actions can also take data provided by other actions:")]),e._v(" "),e._m(55),e._m(56),e._v(" "),e._m(57),e._v(" "),a("p",[e._v("Inside the body you can access this data using params helpers:")]),e._v(" "),e._m(58),a("p",[e._v("To get a category by it's name the following action can be used:")]),e._v(" "),e._m(59),e._m(60),e._v(" "),e._m(61),a("p",[e._v("To clarify the sense of some input parameters we can add auxiliary concepts to the signature:")]),e._v(" "),e._m(62),e._m(63),e._v(" "),e._m(64),e._v(" "),a("p",[e._v("or")]),e._v(" "),e._m(65),e._v(" "),a("p",[e._v("The auxiliary concept can be marked as optional:")]),e._v(" "),e._m(66),e._m(67),e._v(" "),a("p",[e._v("The data parameters can be optional too:")]),e._v(" "),e._m(68),a("p",[e._v("In this case we can return products related to a certain category if we have category data or all the products otherwise.")]),e._v(" "),a("p",[e._v("The input parameters can be implicit:")]),e._v(" "),e._m(69),e._m(70),e._v(" "),e._m(71),e._v(" "),a("p",[e._v('A: Agent will get the category "Jeans"')]),e._v(" "),e._m(72),e._v(" "),a("p",[e._v('A: Agent will get products for category "Jeans"')]),e._v(" "),e._m(73),e._v(" "),e._m(74),e._v(" "),e._m(75),e._v(" "),e._m(76),e._v(" "),e._m(77),e._v(" "),e._m(78),e._v(" "),e._m(79),e._v(" "),e._m(80),e._v(" "),e._m(81),e._v(" "),e._m(82),e._v(" "),e._m(83),e._v(" "),e._m(84),e._v(" "),e._m(85),e._v(" "),e._m(86),e._v(" "),a("p",[e._v("As described in our "),a("a",{attrs:{href:"#actions"}},[e._v("action component")]),e._v(", EBA supports a parameter type called "),a("code",[e._v("promise")]),e._v(", which enables data to be produced for an action only once some prelimenrary data is first acquired. This is typically accomplished by the use of follow up questions in a dialog series. For a live example of this feature, you may try out our "),a("a",{attrs:{href:"https://eba.ibm.com/assistant#/lab/agents/weather/actions",target:"_blank",rel:"noopener noreferrer"}},[e._v("Weather agent"),a("OutboundLink")],1),e._v(". In this article, we will walk you through the steps of implementing a few promise dialogs, using our Weather agent as a reference.")]),e._v(" "),e._m(87),e._v(" "),e._m(88),e._v(" "),a("p",[e._v("Or, let's say that you are resolving a user's question and the runtime execution indicates an ambiguous case which needs to be resolved by a follow up? For example, if the user asks for a certain entity but you need to establish which type or which class it should be belong to. In these cases, a follow up dialog can be used to resolve any disambiguation.")]),e._v(" "),a("p",[e._v("Of course, in all these cases a user can ask a fully qualified question, in which case no follow up dialog is required, e.g. 'show me the weather in San Fransisco two days from now'. However, we do not anticipate or assume that this will always be the case, and, as a result, we enable developers to handle less qualified requests for data.")]),e._v(" "),e._m(89),e._v(" "),e._m(90),a("p",[e._v("From this code, we note two things. First, we rename our concept to "),a("code",[e._v(":Question")]),e._v(" using the "),a("code",[e._v("setName")]),e._v(" api detailed in our "),a("router-link",{attrs:{to:"./../lab/NodeHelpers.html"}},[e._v("node helpers")]),e._v(". Secondly, as data, we supply the follow up question itself. With these two elements in place, our system will be able to understand that "),a("code",[e._v("weather:Weather")]),e._v(" cannot be resolved in the current execution; instead, it should display a follow up question.")],1),e._v(" "),e._m(91),e._v(" "),e._m(92),e._v(" "),e._m(93),e._v(" "),e._m(94),e._v(" "),e._m(95)])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"programming-reference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#programming-reference","aria-hidden":"true"}},[this._v("#")]),this._v(" Programming Reference")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"ontology"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ontology","aria-hidden":"true"}},[this._v("#")]),this._v(" Ontology")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("At a high level, EBA is composed of an ontology of "),a("a",{attrs:{href:"#concepts"}},[e._v("concepts")]),e._v("  and "),a("a",{attrs:{href:"#attributes"}},[e._v("attributes")]),e._v(" that it is able to recognize and reason about. Natural language "),a("a",{attrs:{href:"#patterns"}},[e._v("patterns")]),e._v(" help the assistant to perform natural language understanding, linking language tokens to appropriate concepts. In the process of reasoning about a question, the system considers all possible outcomes it can take given a set of "),a("a",{attrs:{href:"#actions"}},[e._v("actions")]),e._v(" and "),a("a",{attrs:{href:"#rules"}},[e._v("rules")]),e._v(", ultimately selecting the best one or asking for user disambiguation in cases where it is fitting. You can learn more about each of these components as well as a few of our "),a("a",{attrs:{href:"#core-built-in-concepts"}},[e._v("core concepts")]),e._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"warning custom-block"},[t("p",{staticClass:"custom-block-title"},[this._v("WARNING")]),this._v(" "),t("p",[this._v("Add a bit about agents (its always the obvious element that gets left out of discussion...) because it shows up in core concepts")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concepts","aria-hidden":"true"}},[this._v("#")]),this._v(" Concepts")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("A concept is simply an object in your domain that the assistant is able to recognize. For example, in the marketing domain, we have concepts for mailings, open-rates, click-rates, etc. A concept in denoted by a colon "),t("code",[this._v(":")]),this._v(". For example "),t("code",[this._v(":Mailings")]),this._v(" denotes the mailings concepts. Concepts should additionally be prefixed with the domain of your skill. For example, "),t("code",[this._v("marketing:Mailings")]),this._v(" signifies the mailings concept in the marketing domain.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Concepts and their relationship to other concepts are defined in an ontology. In fact, an ontology is simply a set of relationships between different concepts in rdf format, i.e. "),t("em",[this._v("subject-predicate-object")]),this._v(" triples. Consider the following examples below.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(":OpenRate subClassOf :Showable\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(":Mailings isListOf :Mailing\n")])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[a("code",[e._v("subClassOf")]),e._v("  -- "),a("code",[e._v("a subClassOf b")]),e._v(" means that a inherits all of the attributes which b contains. This is particularly useful in the cases that we need to model a hierarchical domain. For instance, "),a("code",[e._v(":SalesOrder subClassOf :Order")]),e._v(" allows a particular entity to auto derive attributes from its base concept.")]),e._v(" "),a("li",[a("code",[e._v("isListOf")]),e._v("    -- "),a("code",[e._v("a listOf b")]),e._v(" means that a is a collection of b. This enables our system to automatically perform data operations on top of collections. For instance, "),a("code",[e._v(":Orders isListOf :Order")]),e._v(" and "),a("code",[e._v(":Order hasAttribute :Quantity")]),e._v(", we immediately begin to ask questions such as 'show me all orders where quantity is above 500'.")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"attributes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#attributes","aria-hidden":"true"}},[this._v("#")]),this._v(" Attributes")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ol",[t("li",[this._v("An attribute concept has to be subclass of "),t("code",[this._v(":Attribute")]),this._v(";")]),this._v(" "),t("li",[this._v("An attribute concept has to be associated with an entity concept by defining an accessor (JSON field name).")])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[e._v("A numeric attribute concept has to be subclass of "),a("code",[e._v(":NumAttribute")]),e._v(";")]),e._v(" "),a("li",[e._v("A string attribute concept has to be subclass of "),a("code",[e._v(":StrAttribute")]),e._v(";")]),e._v(" "),a("li",[e._v("A date attribute concept has to be subclass of "),a("code",[e._v(":DateAttribute")]),e._v(".")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"autogenerated-concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#autogenerated-concepts","aria-hidden":"true"}},[this._v("#")]),this._v(" Autogenerated concepts")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("For every attribute EBA automatically generates all the neccessary components (concepts, ontology, and semantic actions). You may use some of these autogenerated concepts in your semantic actions or visualizers if necessary. If we define the attribute "),t("code",[this._v("example:Price")]),this._v(" as an attribute of "),t("code",[this._v("example:Product")]),this._v(" EBA will generate the following ontology:")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ol",[a("li",[a("code",[e._v("example:Product hasAttribute example:Price")]),e._v(" - this relation may be useful in polymorphic semantic actions or rewriting rules;")]),e._v(" "),a("li",[a("code",[e._v("example:PriceValue, example:PriceValues isValueOf example:Price")]),e._v(" - for every attribute additional concepts are generated which represent actual values of attributes. EBA distinguish singular and plural forms of attribute values. You should refer to these concepts when you define custom visualization for your attributes;")]),e._v(" "),a("li",[a("code",[e._v("attr:ProductPrice attributeOf example:Product, example:Products")]),e._v(" - for every attribute - entity relationship EBA generates an auxiliary concept to hold a JSON field name. These auxiliary concepts are used in OOB semantic actions to sort, filter or rank collections.")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"sharing-the-attributes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sharing-the-attributes","aria-hidden":"true"}},[this._v("#")]),this._v(" Sharing the attributes")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("You can share attribute concepts among different business entities if necessary. For example you can define the attribute "),a("code",[e._v("example:Address")]),e._v(" and then make it as an attribute of both "),a("code",[e._v("example:Customer")]),e._v(" and "),a("code",[e._v("example:Supplier")]),e._v(". EBA will generate two auxiliary concepts to distinguish these attributes: "),a("code",[e._v("attr:CustomerAddress")]),e._v(" and "),a("code",[e._v("attr:SupplierAddress")]),e._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"core-built-in-concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#core-built-in-concepts","aria-hidden":"true"}},[this._v("#")]),this._v(" Core built-in concepts")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[a("a",{attrs:{href:"#user-interface-concepts"}},[e._v("User interface concepts")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#action-concepts"}},[e._v("Action concepts")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#primitive-data-concepts"}},[e._v("Primitive data concepts")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#conditional-concepts"}},[e._v("Conditional concepts")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#aggregation-concepts"}},[e._v("Aggregation concepts")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#qualifier-concepts"}},[e._v("Qualifier concepts")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#nlg-concepts"}},[e._v("NLG concepts")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"user-interface-concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#user-interface-concepts","aria-hidden":"true"}},[this._v("#")]),this._v(" User interface concepts")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[a("p",[a("code",[e._v(":Message")]),e._v(" -- any subclass will be treated as type of message where underlying textual data is propagated as a response to the user. These concepts will be treated as directives to interact with the user rather than as composable data elements. This is particularly useful in cases where you want to interact with the user but not return any associated data, e.g. "),a("code",[e._v("ns:DeleteProduct subClass :Message")]),e._v(" can enable the textual response 'I have deleted your product named abc' when "),a("code",[e._v("data ns:DeleteProduct")]),e._v(" is produced.")])]),e._v(" "),a("li",[a("p",[a("code",[e._v(":Showable")]),e._v(" -- any subclass will be treated as a showable entity. This entity can be visualized using our standard assets and displayed to the user in our chat, graph, and content views. If a entity is not "),a("code",[e._v(":Showable")]),e._v(", then it will not recieve a high score when used in conjunction with "),a("code",[e._v(":ActionShow")]),e._v(".")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"action-concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#action-concepts","aria-hidden":"true"}},[this._v("#")]),this._v(" Action concepts")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("All action concepts are a subclass of "),t("code",[this._v(":Message")]),this._v(" as they reprsent operations by the machine which require user interaction, e.g. show data elements or remove data elements will produce the appropriate message to the user. The following concepts are analogous to CRUD operations, all which are supported by our system.")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[a("p",[a("code",[e._v(":ActionCreate")]),e._v(" -- concept which represents a user's request to have data created. It will create data and post a message to the user.")])]),e._v(" "),a("li",[a("p",[a("code",[e._v(":ActionShow")]),e._v(" -- concept which represents an user's request to have data shown. It will produce "),a("code",[e._v(":Showable")]),e._v(" data.")])]),e._v(" "),a("li",[a("p",[a("code",[e._v(":ActionModify")]),e._v(" -- concept which represents a user's request to have data updated. It will modify data and post a message to the user.")])]),e._v(" "),a("li",[a("p",[a("code",[e._v(":ActionDelete")]),e._v(" -- concept which represents a user's request to have data removed. It will remove data and produce a textual response to the user.")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"primitive-data-concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#primitive-data-concepts","aria-hidden":"true"}},[this._v("#")]),this._v(" Primitive data concepts")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[a("code",[e._v(":UserString")]),e._v(" -- underlying data within quoted strings.")]),e._v(" "),a("li",[a("code",[e._v(":Number")]),e._v("     -- a numeric value.")]),e._v(" "),a("li",[a("code",[e._v(":Timeframe")]),e._v("  -- a timeframe element containing information such as the start and end of the timeframe as well as its level of grainularity.")]),e._v(" "),a("li",[a("code",[e._v(":FreeText")]),e._v("   -- textual input form user's question which is not consumed by any other actions within a particular variant. This concept can be useful in cases where more free-formed input is expected.")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"conditional-concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#conditional-concepts","aria-hidden":"true"}},[this._v("#")]),this._v(" Conditional concepts")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[a("code",[e._v(":Contains")]),e._v("    -- condition which signifies that source value contains target value.")]),e._v(" "),a("li",[a("code",[e._v(":StartsWith")]),e._v("  -- condition which signifies that source value starts with target value.")]),e._v(" "),a("li",[a("code",[e._v(":EndsWith")]),e._v("    -- condition which signifies that source value ends with target value.")]),e._v(" "),a("li",[a("code",[e._v(":Like")]),e._v("        -- condition which signifies that source value matches target value in a fuzzy search.")]),e._v(" "),a("li",[a("code",[e._v(":GreaterThan")]),e._v(" -- condition which signifies that source value is greater than target value.")]),e._v(" "),a("li",[a("code",[e._v(":LessThan")]),e._v("    -- condition which signifies that source value is less than target value.")]),e._v(" "),a("li",[a("code",[e._v(":Equivalent")]),e._v("  -- condition which signifies that source value is strictly equal to the target value.")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"aggregation-concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aggregation-concepts","aria-hidden":"true"}},[this._v("#")]),this._v(" Aggregation concepts")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("These concepts represent aggregration and modifier operations on top of collections. Typically these concepts will be used in conjunction with certain predicates and collections, e.g. "),t("code",[this._v(":SortedBy(:Quantity, :SalesOrders)")]),this._v(".")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[a("code",[e._v(":TopN")]),e._v("      -- gets the top N elements within a collection")]),e._v(" "),a("li",[a("code",[e._v(":SortedBy")]),e._v("  -- sorts a collection by a criteria")]),e._v(" "),a("li",[a("code",[e._v(":Filter")]),e._v("    -- filter a collection")]),e._v(" "),a("li",[a("code",[e._v(":First")]),e._v("     -- get the first element in a collection")]),e._v(" "),a("li",[a("code",[e._v(":Largest")]),e._v("   -- get the largest element in a collection")]),e._v(" "),a("li",[a("code",[e._v(":HighValue")]),e._v(" -- gets elements within a collection within the highest quartile")]),e._v(" "),a("li",[a("code",[e._v(":LowValue")]),e._v("  -- gets elements within a collection within the lowest quartile")]),e._v(" "),a("li",[a("code",[e._v(":Average")]),e._v("   -- get the average value across a collection")]),e._v(" "),a("li",[a("code",[e._v(":Total")]),e._v("     -- get the sum total value across a collection")]),e._v(" "),a("li",[a("code",[e._v(":Minimum")]),e._v("   -- get the minimum element within a collection")]),e._v(" "),a("li",[a("code",[e._v(":Maximum")]),e._v("   -- get the maximum element within a collection")]),e._v(" "),a("li",[a("code",[e._v(":MinimumBy")]),e._v(" -- get the minimum element by a particular predicate within a colleciton")]),e._v(" "),a("li",[a("code",[e._v(":MaximumBy")]),e._v(" -- get the maximum element by a particular predicate within a colleciton")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"qualifier-concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#qualifier-concepts","aria-hidden":"true"}},[this._v("#")]),this._v(" Qualifier concepts")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("These concepts represent certain language qualifiers for designated entities. Often times these qualifiers can be ommitted in natural language, and, consequently, they are often denoted as "),t("code",[this._v("optional")]),this._v(" when used within semantic actions.")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[a("code",[e._v(":WithName")]),e._v(" -- qualifier which references a value as being the name of an entity, e.g. 'show product "),a("em",[e._v("named")]),e._v(" iPhone X.")]),e._v(" "),a("li",[a("code",[e._v(":WithId")]),e._v("   -- qualifier which references a value as being the id of an entity, e.g. 'show product "),a("em",[e._v("id")]),e._v(" 123.")]),e._v(" "),a("li",[a("code",[e._v(":Relation")]),e._v(" -- qualifier which explictly denotes the relationship between two entities, e.g. show me contacts "),a("em",[e._v("in")]),e._v(" this org.")]),e._v(" "),a("li",[a("code",[e._v(":All")]),e._v("      -- qualifier which explictly denotes that all entities should be qualified, e.g. 'show me "),a("em",[e._v("all")]),e._v(" sales orders'.")]),e._v(" "),a("li",[a("code",[e._v(":Own")]),e._v("      -- qualifier which explictly denotes entities belonging to the user, e.g. 'show me "),a("em",[e._v("my")]),e._v(" contacts'.")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"nlg-concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nlg-concepts","aria-hidden":"true"}},[this._v("#")]),this._v(" NLG Concepts")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[a("code",[e._v("nlg:PostModifier")]),e._v(" -- denotes that the spelling for a particular concept operates as a post modifier, e.g. 'show me complaints "),a("em",[e._v("against")]),e._v(" this product'.")]),e._v(" "),a("li",[a("code",[e._v("nlg:PreModifier")]),e._v(" -- denotes that the spelling for a particular concept operates as a pre modifier, e.g. 'show me "),a("em",[e._v("late")]),e._v(" sales orders'.")]),e._v(" "),a("li",[a("code",[e._v("nlg:PlainText")]),e._v("   -- used within NLToken interface to denote a plain text entry, where the data supplied to this concept will be spelled as is.")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"patterns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#patterns","aria-hidden":"true"}},[this._v("#")]),this._v(" Patterns")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("show [trending](wmt:Trending) [products](wmt:Products)\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("This pattern tells the system that trending and products tokens correspond to the concepts "),t("code",[this._v("wmt:Trending")]),this._v(" and "),t("code",[this._v("wmt:Products")]),this._v(' respectively. From now on, the system will recognize and consider "trending" and "products" appropriately for all further input. Additionally, it is able to capture the syntactic part of speech tree associated with these tokens.')])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"best-practices"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#best-practices","aria-hidden":"true"}},[this._v("#")]),this._v(" Best practices")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("It is best to enter patterns in a way that logically separates concepts. For instance, "),t("code",[this._v("show me [product id](:ProductId)")]),this._v(' actually annotates two concepts as one, viz. "product" and "id". The better practice is to enter patterns for id and patterns for product separately, since they are actually two different concepts, viz. '),t("code",[this._v("[id](wmt:Identifier)")]),this._v(" and "),t("code",[this._v("[product](wmt:Product)")]),this._v(". In applications with multiple business entities and multiple ways to refer to these entities, you will find yourself entering many unnecessary patterns if you do not separate them appropriately.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Also note that individual patterns should not be placed within one entry, e.g. "),t("code",[this._v("[\\#](:IDSign), [id](:IDSign), [no](:IDSign), [no.](:IDSign), [num](:IDSign)")]),this._v(' will represent :IDSign as being equivalent to "# id no no. num". Rather, these patterns should be entered individually as a way to create equivalent references to the '),t("code",[this._v(":IDSign")]),this._v(" concept.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"rules"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rules","aria-hidden":"true"}},[this._v("#")]),this._v(" Rules")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Rewriting rules are a way to transform one single concept into a cluster of other related concepts. Each skill may contain a set of rules, where each rule is designated by a set of "),t("a",{attrs:{href:"#constraints"}},[this._v("constraints")]),this._v(", "),t("a",{attrs:{href:"#input-and-output"}},[this._v("input and output")]),this._v('. Often times natural language can be very short and allow for the omission of certain words or concepts. Rewriting rules enable the assistant to handle such cases effectively. While our concepts are well formed, we anticipate that users will use imprecise language to inquire about them. For example, we might expect a user to ask for "the best mailing" or "trending products". We can implement rewriting rules to reduce higher-level notions such as "best" and "trending" into a cluster of concepts that the assistant can more easily reason about. For example consider the rewriting rule below.')])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(":TheBest(:Mailing) -> :HighValue(:ClickToOpenRate, :Mailings)\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"constraints"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constraints","aria-hidden":"true"}},[this._v("#")]),this._v(" Constraints")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("Constraints are simply a way to qualify your concepts using rdf triples. As in the case of ontology, constraints follow the format of "),a("em",[e._v("subject")]),e._v(", "),a("em",[e._v("predicate")]),e._v(", "),a("em",[e._v("object")]),e._v(", where the subject and object must be either a concept or another symbol and predicate can be anything as long as it is used consistently within your configuration. Constraints are used within EBA to denote a polymorphic parameter. For instance, "),a("code",[e._v("a subClassOf :List")]),e._v(" constrains the symbol "),a("code",[e._v("a")]),e._v(" to be "),a("em",[e._v("any")]),e._v(" list. Constraints only hold scope local to the signature they are defined in. Within our Lab, a warning will be issued if a constraint is defined but never actually used within the remainder of the signature. Likewise, a warning will be issued a constraint symbol is used within the signature but never declared. Hence, "),a("code",[e._v("a subClassOf :RankingMetric => :Mailings -> data :Mailings")]),e._v(" contains a superfluous constraint, while "),a("code",[e._v(":Mailings(a) -> :Mailings")]),e._v(" contains an undeclared symbol "),a("code",[e._v("a")]),e._v(". A valid signature would be the following "),a("code",[e._v("a subClassOf :RankingMetric => :Mailings(a) -> data :Mailings")]),e._v(". Additionally, constraints may make use of a wildcard symbol to denote that it accepts any type, e.g. "),a("code",[e._v("a isListOf _")]),e._v(" denotes a constraint "),a("code",[e._v("a")]),e._v(" that is a list of anything.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("In certain cases, it is possible to refer to a constraint parameter multiple times within a single signature, so it is necessary to distinguish between these references. For instance, "),t("code",[this._v("a subClassOf :Showable => a(reference:Direct, context data a @src)")]),this._v(" makes uses of the constraint parameter "),t("code",[this._v("a")]),this._v(" twice. To distinguish the second occurrence of the parameter, we add an alias: "),t("code",[this._v("@src")]),this._v('. Now, within the body of our action, we can require data by indexing our deps as "src".')])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"input-and-output"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#input-and-output","aria-hidden":"true"}},[this._v("#")]),this._v(" Input and output")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Both input and output to rules are represented as a tree of concepts. There are no "),t("code",[this._v("paramTypes")]),this._v(" or "),t("code",[this._v("queryTypes")]),this._v(" associated with these concepts. A rule will effectively translate the input (higher level) into the output (lower level).")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"actions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#actions","aria-hidden":"true"}},[this._v("#")]),this._v(" Actions")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("Actions are the means by which the assistant can provide real data to corresponding concepts. Each skill will contain a set of actions, where each action is designated by a set of "),a("a",{attrs:{href:"#constraints"}},[e._v("constraints")]),e._v(", "),a("a",{attrs:{href:"#input"}},[e._v("input")]),e._v(", and "),a("a",{attrs:{href:"#output"}},[e._v("output")]),e._v(". An action's signature follows the format "),a("code",[e._v("constraints => input -> output")]),e._v(". Given an configuration of input concepts subject to certain constraints, the system will be able to produce the specified output after executing the body of the action. In addition to this signature, an action will have a name as well as a function to be invoked when the action is selected. For example consider the action below:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(":Products(:Trending) -> data :Products\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Note that this action does not have any constraints - constraints are optional. This action effectively states that if the assistant recognizes a "),t("code",[this._v(":Products")]),this._v(" concept as well as a "),t("code",[this._v(":Trending")]),this._v(" concept, then the system can produce real data for the "),t("code",[this._v(":Products")]),this._v(" concepts. The data will be produced by the body of this action, which can query a database, call an api, etc.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(":Products(data :Category) -> data :Products\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("This action will expect a data node "),t("code",[this._v(":Category")]),this._v(" which has to be created by another action. The action can be triggered once the user asks for products by category, for example:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Q: "),t("em",[this._v('show me products for category "Jeans"')])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('const eba = require("eba")\nmodule.exports.main = async function(params) {\n\tlet p = new eba.Params(params)\n\tlet category = await p.get(":Category")\n\tlet products = ... get products by category here\n\treturn new eba.Result().setData(":Products", products)\n}\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(":Category(data :UserString) -> data :Category\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Processing of quoted strings is available out of the box. Each quoted string will be annotated with "),t("code",[this._v(":UserString")]),this._v(" concept and the corresponding data will be created. So you can just get this data in your action body:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('let categoryName = await p.get(":UserString")\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(":Category(:WithName(data :UserString)) -> data :Category\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("In this case the action will be triggered "),t("strong",[this._v("ONLY")]),this._v(" when "),t("code",[this._v(":UserString")]),this._v(" node has an auxiliary neighbor concept "),t("code",[this._v(":WithName")]),this._v(" as in questions like:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Q: "),t("em",[this._v('show me products for category named "Jeans"')])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Q: "),t("em",[this._v('show me products for category with name "Jeans"')])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(":Category(optional :WithName(data :UserString)) -> data :Category\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("This action can be triggered in both questions with or without the concept "),t("code",[this._v(":WithName")]),this._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(":Products(optional data :Category) -> data :Products\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(":Products(implicit data :Category) -> data :Products\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("This action can be triggered without the "),t("code",[this._v(":Category")]),this._v(" concept in the question thread (an optional parameter) but the agent will still be able to search for the "),t("code",[this._v(":Category")]),this._v(" concept data in the context. For example the following scenario will work with implicit "),t("code",[this._v(":Category")]),this._v(" parameter:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Q: "),t("em",[this._v('show me category "Jeans"')])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Q: "),t("em",[this._v("show me products")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("If no concept found in the context the agent will try to recover this concept data using available actions so we will be able to ask questions like "),t("em",[this._v('show me products for "Jeans"')]),this._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"constraints-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constraints-2","aria-hidden":"true"}},[this._v("#")]),this._v(" Constraints")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("Constraints are simply a way to qualify your concepts using rdf triples. As in the case of ontology, constraints follow the format of "),a("em",[e._v("subject")]),e._v(", "),a("em",[e._v("predicate")]),e._v(", "),a("em",[e._v("object")]),e._v(", where the subject and object must be either a concept or another symbol and predicate can be anything as long as it is used consistently within your configuration. Constraints are used within EBA to denote a polymorphic parameter. For instance, "),a("code",[e._v("a subClassOf :List")]),e._v(" constrains the symbol "),a("code",[e._v("a")]),e._v(" to be "),a("em",[e._v("any")]),e._v(" list. Constraints only hold scope local to the signature they are defined in. Within our Lab, a warning will be issued if a constraint is defined but never actually used within the remainder of the signature. Likewise, a warning will be issued a constraint symbol is used within the signature but never decalred. Hence, "),a("code",[e._v("a subClassOf :RankingMetric => :Mailings -> data :Mailings")]),e._v(" contains a superfluous constraint, while "),a("code",[e._v(":Mailings(a) -> :Mailings")]),e._v(" contains an undeclared symbol "),a("code",[e._v("a")]),e._v(". A valid signature would be the following "),a("code",[e._v("a subClassOf :RankingMetric => :Mailings(a) -> data :Mailings")]),e._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("In certain cases, it is possible to refer to a constraint parameter multiple times within a single signature, so it is necessary to distinguish between these references. For instance, "),t("code",[this._v("a subClassOf :Showable => a(reference:Direct, context data a @src)")]),this._v(" makes uses of the constraint parameter "),t("code",[this._v("a")]),this._v(" twice. To distinguish the second occurrence of the parameter, we add an alias: "),t("code",[this._v("@src")]),this._v('. Now, within the body of our action, we can require data by indexing our deps as "src".')])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"paramtype-and-querytype"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#paramtype-and-querytype","aria-hidden":"true"}},[this._v("#")]),this._v(" ParamType and queryType")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("Concepts within a signature can be qualified with additional specifications to apply different semantics to your action. These specifications are applied through the use of "),a("code",[e._v("paramTypes")]),e._v(" and "),a("code",[e._v("queryTypes")]),e._v(". "),a("code",[e._v("paramTypes")]),e._v(" qualify the parameters within a given signature, while "),a("code",[e._v("queryTypes")]),e._v(" qualify the actual query.")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("We support three "),a("code",[e._v("paramTypes")]),e._v(", viz. "),a("code",[e._v("concept")]),e._v(", "),a("code",[e._v("data")]),e._v(", and "),a("code",[e._v("promise")]),e._v(". "),a("code",[e._v("concept")]),e._v(" is the default "),a("code",[e._v("paramType")]),e._v(" and no keyword is required to denote it. It simply signifies that a signature requires a given concept to be present in the parse tree. "),a("code",[e._v("data")]),e._v(" denotes the real data associated with an action (which is produced by another action). For instance, "),a("code",[e._v("edi:Submit(data edi:Invoice)")]),e._v(" denotes a submission request that requires real invoice data. "),a("a",{attrs:{href:"#promises"}},[e._v("promise")]),e._v(" is used to denote a concept which we intend to cover with real data once some further preliminary data is acquired, e.g. promises to return weather data once the user's geo location is ascertained.")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("We support four "),a("code",[e._v("queryTypes")]),e._v(", viz. "),a("code",[e._v("regular")]),e._v(", "),a("code",[e._v("optional")]),e._v(", "),a("code",[e._v("context")]),e._v(", and "),a("code",[e._v("implicit")]),e._v(". "),a("code",[e._v("regular")]),e._v(" is the default "),a("code",[e._v("queryType")]),e._v(" and no keyword is required to denote it. It simply signifies that a query matches a concepts in the current question as expected. "),a("code",[e._v("optional")]),e._v(" qualifies the query to accept an optional parameter, e.g. "),a("code",[e._v(":Mailings(optional :All)")]),e._v(' means that our action can support questions such as "show me all mailings" or simply "show me mailings". '),a("code",[e._v("context")]),e._v(" means that our query can search the conversational context for a parameter. For instance, "),a("code",[e._v("edi:Modify (context data edi:Invoice)")]),e._v(" is an action which modifies an already invoice. "),a("code",[e._v("implicit")]),e._v(" is like "),a("code",[e._v("context")]),e._v(" but different insofar as it gives the assistant license to create new concepts through the use of other actions before executing the current action. For instance, if we have one action as "),a("code",[e._v(":SendVolume(optional :Relation(implicit data :Mailings))")]),e._v(" and another action as "),a("code",[e._v(":Mailings -> data :Mailings")]),e._v(", then, when answering a question about send volume, the assistant may execute the mailings action first in order to have data to complete the action for send volume. Mailings nodes will be tagged within the information space as "),a("code",[e._v("virtual")]),e._v(". Because "),a("code",[e._v("implicit")]),e._v(" actions may create additional concepts as a side effect and thus significantly alter the complexity of answering a question, they should be used judiciously. In fact, you should try to avoid "),a("code",[e._v("implicit")]),e._v(" parameters whenever possible. Both "),a("code",[e._v("context")]),e._v(" and "),a("code",[e._v("implicit")]),e._v(" should only be used to qualify "),a("code",[e._v("data")]),e._v(" nodes.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"input"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#input","aria-hidden":"true"}},[this._v("#")]),this._v(" Input")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("An action's input is represented as a tree of concepts. These concepts must be matched against in order for the action to be selected for execution. The concepts in this tree may be qualified with "),a("code",[e._v("paramTypes")]),e._v(" and "),a("code",[e._v("queryTypes")]),e._v(". A common usage of "),a("code",[e._v("paramTypes")]),e._v(" within input is to specify that an action requires real data. For instance, "),a("code",[e._v("sc:Order(sc:Identifier)")]),e._v(' will fire when the system notices a request such as "show me order #1234", however, it will not supply the real data associated with the identifier, viz. 1234, to your action since it is only requiring the '),a("code",[e._v("concept")]),e._v(" "),a("code",[e._v("sc:Identifier")]),e._v(" to be present. To make use of this real data, i.e. to signify that "),a("code",[e._v("sc:Idenifier")]),e._v(" is a parameter with "),a("code",[e._v("data")]),e._v(", input should be denoted as "),a("code",[e._v("sc:Order(data sc:Identifier)")]),e._v(". A common usage of "),a("code",[e._v("queryTypes")]),e._v(" within an input is to denote that a parameter may be taken from already existing context. For instance, "),a("code",[e._v(":Confirmation(context data expo:DeleteProduct)")]),e._v(" requires real data associated with a deleted product to already exist within the context of the conversation--which makes sense given that this action is a confirmation request. As you can see from this example, both "),a("code",[e._v("paramTypes")]),e._v(" and "),a("code",[e._v("queryTypes")]),e._v(" can be used in conjunction with one another when defining an input signature.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Since input is represented as a tree, an ordering is imposed on the concepts. For instance, "),t("code",[this._v(":News(:Relation(:Organization)) -> data :News")]),this._v(' implies the following ordering "news" -> "related to" -> "organization". EBA is able to understand such inherent dependencies when it builds the syntax tree for your question, enabling it to distinguish between a similar question such as "organization" -> "related to" -> "news".')])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"output"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#output","aria-hidden":"true"}},[this._v("#")]),this._v(" Output")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Whereas input was a tree, output is simply a flat list of concepts. These concepts can only be qualified with "),t("code",[this._v("paramTypes")]),this._v(". Most often the output of an action is strictly a single concept qualified as data, e.g. "),t("code",[this._v("-> data Mailings")]),this._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"promises"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promises","aria-hidden":"true"}},[this._v("#")]),this._v(" Promises")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"asking-for-follow-up-information"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#asking-for-follow-up-information","aria-hidden":"true"}},[this._v("#")]),this._v(" Asking for follow-up information")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Let's say that you have a business entity which requires, as a necessary condition in order to fetch the entity, another data element(s). In our case, this is "),t("code",[this._v("weather:Weather")]),this._v(" which requires both a city as well as a timeframe.")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("To handle less qualified requests, the following strategy can be employed. When a reference to your entity occurs, you can implement an action which returns a "),a("code",[e._v("promise")]),e._v(" node as output, rather than a "),a("code",[e._v("data")]),e._v(" node. For instance, "),a("code",[e._v("weather:Weather -> promise weather:Weather")]),e._v(" signifies an unqualified case (the users asks something general as 'what is the weather?'). We cannot produce "),a("em",[e._v("data")]),e._v(" for "),a("code",[e._v("weather:Weather")]),e._v(" until we first obtain a location. The code for such an action can look something like the following:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("const {Result} = require('eba')\n\nmodule.exports.main = (params) => {\n  return new Result()\n    .setName('weather:Weather', ':Question')\n    .setData('weather:Weather', 'Which location should I get the weather for?')\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Note that more complex cases can be modeled, e.g. our "),t("code",[this._v("weather:Forecast")]),this._v(" requires both a timeframe as well as a location in order for data to be produced. We can either model this a 3-step sequence, viz. ask for forecast, ask for location, and, finally, ask for timeframe. Or we can model it as 2-step sequence, viz. ask for forecast and timeframe or location and then ask for the remaining element. Or we can be flexible enough to support both variants. This will depend largely on the agent's business requirements. In our implementation of "),t("code",[this._v("weather:Forecast")]),this._v(", we have followed the second route. Accordingly, you will find the following signatures in our implementation:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[t("code",[this._v("weather:Forecast(optional :Relation(data :Timeframe) -> promise weather:Forecast")])]),this._v(" "),t("li",[t("code",[this._v("weather:Forecast(optional :Relation(city)) -> promise weather:Forecast")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("You will find that the body of such actions all follow the similar pattern described above, viz. rename to "),t("code",[this._v(":Question")]),this._v(" with supplied NL question.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"generating-data"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generating-data","aria-hidden":"true"}},[this._v("#")]),this._v(" Generating data")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("With a "),a("code",[e._v("promise")]),e._v(" node in place, our system will attempt to resolve it, i.e. to convert it to a "),a("code",[e._v("data")]),e._v(" node, whenever it is suitable. To enable such behavior, we should implement an additional action to produce real data. Of course, this action will contain as input all concepts required to resolve the entity at hand. In the case of weather, we have an action as "),a("code",[e._v("weather:Forecast")]),e._v(", we have an action "),a("code",[e._v("weather:Forecast (optional :Relation (data city), optional :Relation (data :Timeframe)) -> data weather:Forecast")]),e._v(". Note that this action requires both city and timeframe data and the output produces "),a("code",[e._v("data weather:Forecast")]),e._v(", meaning that it can provide the data which the user initially requested. The body of this action will use the supplied input to perform any api calls necessary. All actions for the weather agent as viewable to our users. Feel free to take a look and explore this feature in your own implementations.")])}],!1,null,null,null);t.default=s.exports}}]);