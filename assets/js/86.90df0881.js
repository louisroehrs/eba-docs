(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{267:function(e,t,n){"use strict";n.r(t);var i=n(0),o=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h2",{attrs:{id:"annotate-mode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#annotate-mode","aria-hidden":"true"}},[e._v("#")]),e._v(" Annotate mode")]),e._v(" "),n("p",[e._v("EBA provides developers with a few unique system directives for processing NL input. One input directive is "),n("code",[e._v("||debug")]),e._v(" which allows developers to run EBA strictly in reasoning mode in order to produce all variants of understanding as an output. While debug mode does well at considering all possible outcome paths, it is often a case that a developer would like to verify the annotation tree without the additional overhead of running full reasoning. Recall that debug mode also clutters the information space, as possible variants are displayed in this case. To this end, we have provide the "),n("code",[e._v("||annotate")]),e._v(" directive to developers. This directive will run the annotation step of our execution pipeline in order to verify that the concepts which the developer intend are found within the annotation tree of a given quesiton.")])])}],!1,null,null,null);t.default=o.exports}}]);