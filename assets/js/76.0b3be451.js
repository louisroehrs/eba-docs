(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{254:function(e,t,n){"use strict";n.r(t);var a=n(0),s=Object(a.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[e._m(0),e._v(" "),n("p",[e._v("EBA can provide native rendering for a few popular communication channels. Currently, we support Slack and Watson Workspace. The rendering format is, of course, dependent upon the api exposed by such channels. Be advised that EBA already has a default mechanism for rendering messages in such channels. By default, Watson will take a clickable snapshot of the original message that would otherwise be rendered within our web application and post it as an image link to the channel. Within the channel, this message can be clicked to engage into a full view of the message data. You should consider using the render endpoint if you desire to override this default behavior by using the native formatting provided by a particular channel. Within the endpoint, you will have the following information supplied as input:")]),e._v(" "),e._m(1),e._v(" "),n("p",[e._v("If node data size exceeds certain limit it maybe be represented as lazy data. The best way to handle such cases is to use the helper function which will request the actual node data in the case it's represented as lazy data.")]),e._v(" "),n("p",[e._v("Slack Example:")]),e._v(" "),e._m(2),n("p",[e._v("For full documentation and interactive explorer on Slack's message format, consult their "),n("a",{attrs:{href:"https://api.slack.com/docs/messages",target:"_blank",rel:"noopener noreferrer"}},[e._v("official docs"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("Workspace Example:")]),e._v(" "),e._m(3),n("p",[e._v("Workspace supports two types of render formats--Message, File, or a JSON array of both.")]),e._v(" "),n("p",[e._v("Message:")]),e._v(" "),e._m(4),e._v(" "),n("p",[e._v("File:")]),e._v(" "),e._m(5),e._v(" "),n("p",[e._v("The example above demonstrates how to send an array of both types of formats.")])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"render-endpoint"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#render-endpoint","aria-hidden":"true"}},[this._v("#")]),this._v(" Render Endpoint")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("channel -- the name of the channel, so you can render appropriately for each")]),this._v(" "),t("li",[this._v("message -- a node contains the natural language text, concept name and the data to be rendered")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("const eba = require('eba')\n\nasync function render(channel, h) {\n    if (channel == 'slack') {\n        if (h.getName('message') == 'wmt:Products') {\n            let data = await h.get('message')\n            let attachments = data.map(renderProduct)\n            return {\n                text: h.getMeta('message').text,\n                attachments: attachments\n            }\n        }\n    \n        if (h.getName('message') == 'wmt:Product') {\n            let data = await h.get('message')\n            return {\n                text: h.getMeta('message').text,\n                attachments: [renderProduct(data)]\n            }\n        }\n    }\n}\n\nmodule.exports.main = async function (params) {\n    let result = await render(params.input.channel, new eba.Params(params))\n    if (result) {\n        return { output: result }\n    } else {\n        return {}\n    }\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("const eba = require('eba')\nconst {toCSV} = require('./util.js')\nconst _ = require('lodash')\n\nasync function render(channel, h) {\n    let name = h.getName('message')\n\n    if (channel == 'workspace' && name == 'sc:Orders') {\n        let token = h.getMeta('message')\n        let data = await h.get('message')\n\n        return [\n            { text: token.text , title: _.trimStart(name, 'sc:')},\n            { name: 'orders.csv', body: Buffer.from(toCSV(data)).toString('base64') }\n        ]\n    }\n}\n\nmodule.exports.main = async function (params) {\n    let result = await render(params.input.channel, new eba.Params(params))\n    if (result) {\n        return { output: result }\n    } else {\n        return {}\n    }\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("- text: the actual natural language text answering users question\n- title: title heading displayed over response\n- color: the color of nl text\n- actor: the entity responsible for sending the message\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("- name: the name of the file attachment\n- body: data content of the attachment (must be base64 encoded)\n- dims: dimensions of the image attachment (used for images only)\n")])])}],!1,null,null,null);t.default=s.exports}}]);